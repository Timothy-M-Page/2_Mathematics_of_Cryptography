

# A group G is a set of objects a,b,c... with a binary operation *
# satisfying the four following axioms:

# 1. Closure - For all elements in G, a and b, a*b is also in G.
# 2. Associativity - a * ( b * c ) = ( a * b ) * c
# 3. Identity element - There exists and element I such that I * a = a = a * I for all a in G.
# 4. Inverse elements - For every element g in G, there exists another element h such that g*h = I

# Note that groups may or may not be commutative.

# We will most commonly be working with commutative finite groups of integers,
# with the binary operation being multiplication taken modulo the size of the group.


# Group Operations :

def group(n):                         # Set of n integers from 1 to n.
    return set(range(1, n+1))


def prod(x, y, mod):                  # Modular multiplication
    return x*y % mod


# An inverse function may be implemented for finding inverses in the
# group of integers mod p, for a prime number p, by using the extended
# Euclidean algorithm. If (a,p) = 1, we may write ax + yp = 1 for integers x and y.
# Taking this equation mod p returns ax = 1 mod p, that is, x is the mod p inverse of a.

def extended_euclid(a, b):       # To find the gcd of the integers a and b.
    if a == 0:
        return [b, [0, 1]]
    if b == 0:
        return [a, [1, 0]]       # Handle the case that one or both of the inputs is zero.
    A = max(a, b)
    B = min(a, b)
    r = A % B
    q = A//B
    R = [A, B, r]   # Remainders
    Q = [q]         # Quotients
    S = [1, 0]      # The sets S and T allow the integer coefficients to be calculated iteratively
    T = [0, 1]      # that allow the gcd to be expressed as ax + by = gcd.
    while R[-1] != 0:
        q = R[-2]//R[-1]
        Q.append(q)
        r = R[-2] % R[-1]
        R.append(r)
        s = S[-2] - Q[-2]*S[-1]
        S.append(s)
        t = T[-2] - Q[-2]*T[-1]
        T.append(t)
    if a == A:
        return [R[-2], S[-1], T[-1]]    # Returns the gcd and the integer coefficients allowing the gcd
    else:                               # to be expressed as a linear combination of a and b.
        return [R[-2], T[-1], S[-1]]


def gcd(a, b):
    return extended_euclid(a,b)[0]

# Python implements the extended Euclidean algorithm with the pow function:


def inv(a, mod):
    if gcd(a, mod) > 1:
        return str(a) + " has no inverse mod " + str(mod)
    return pow(a,-1,mod)


# An efficient algorithm for exponentiation may be implemented by writing
# the exponent in binary to break it into a sum of powers of two, each of which
# may be individually calculated and then multiplied to perform the exponentiation:

def fast_power(g, n, mod):          # Fast Power calculation of g**n under the modulus mod
    result = 1
    binary = bin(n)[2:][::-1]       # Binary string representing the exponent
    powers = [g]
    i = g
    for x in range(1,len(binary)):
        i = i ** 2 % mod
        powers.append(i)            # Create an array of the element g raised to powers of two.
    for x in range(len(binary)):
        if int(binary[x]) == 1:
            result = result * powers[x] % mod   # Construct g**n using these powers and the binary string.
    return result

# The fast_power algorithm calculates in O(log_2(n)) multiplications
# instead of the O(n) multiplications of ordinary exponentiation.


def log(g, x, mod):                      # Discrete Logarithm function (DLM) - g to which power gives x.
    for i in range(1, mod+1):            # The NP nature of the DLM is central to the security
        if fast_power(g, i, mod) == x:   # of both the RSA and elliptic curve cryptosystems.
            return i



# Group Generation


def subgroup(g, mod):        # The subgroup of group(n) generated by the element g.
    G = []
    for i in range(1, mod):
        if fast_power(g, i, mod) not in G:
            G.append(fast_power(g, i, mod))
    return G


def ord(g, mod):                      # The order of an element is the size of the subgroup it generates
    return len(subgroup(g,mod))       # By Lagrange's theorem, the order of an element always divides the size of the group


def generators(mod):         # The set of elements of group(n) that generate group(n).
    G = []
    for g in group(mod):
        if ord(g, mod) == mod-1:
            G.append(g)
    return G

# Groups that can be generated by a single element are called cyclic.




# Galois Fields :

# A field may be considered as an extension of a group, where instead of a single binary operation
# We have four binary operations representing addition, subtraction, multiplication and division
# analogous to arithmetic on the set of real numbers.

# Galois fields are composed of a finite number of elements by considering
# integers modulus a given integer, analogous to group(n).

# A set of integers group(n) only forms a field if n the modulus is a prime number.
# If the modulus is composite then any elements sharing an element with the modulus
# cannot have an inverse.


def field(p):                          # p denotes the prime modulus of the field.
    return set(range(1, p + 1))


def add(x, y, p):
    return (x + y) % p


def subtract(x, y, p):
    return (x - y) % p


def multiply(x, y, p):
    return x * y % p


def divide(x, y, p):
    return x * inv(y,p) % p



